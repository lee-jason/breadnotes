name: Deploy to App Runner

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build production Docker image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: breadnotes-api
        IMAGE_TAG: ${{ github.sha }}
      run: |
        echo "Building production Docker image..."
        docker build --target production -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG ./api
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest

    - name: Push image to ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: breadnotes-api
        IMAGE_TAG: ${{ github.sha }}
      run: |
        echo "Pushing image to ECR..."
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

    # - name: Setup database user and schema
    #   run: |
    #     echo "Setting up breadnotes user and database in Supabase..."
        
    #     # First, create the breadnotes user if it doesn't exist
    #     docker run --rm postgres:15 psql \
    #       "postgresql://postgres.zmwhbssepcywbiahpisi:${{ secrets.DB_PASSWORD }}@aws-1-us-east-1.pooler.supabase.com:5432/postgres" \
    #       -c "
    #       -- Create breadnotes user if it doesn't exist
    #       DO \$\$ BEGIN
    #         IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = 'breadnotes') THEN
    #           CREATE USER breadnotes WITH PASSWORD '${{ secrets.DB_PASSWORD }}';
    #           RAISE NOTICE 'Created user breadnotes';
    #         ELSE
    #           RAISE NOTICE 'User breadnotes already exists';
    #         END IF;
    #       END \$\$;
    #       "

    #     # Create the breadnotes database if it doesn't exist (separate command since CREATE DATABASE can't be in DO block)
    #     docker run --rm postgres:15 psql \
    #       "postgresql://postgres.zmwhbssepcywbiahpisi:${{ secrets.DB_PASSWORD }}@aws-1-us-east-1.pooler.supabase.com:5432/postgres" \
    #       -c "CREATE DATABASE breadnotes OWNER breadnotes" 2>/dev/null || echo "Database breadnotes may already exist"

    #     # Set up permissions on the breadnotes database
    #     docker run --rm postgres:15 psql \
    #       "postgresql://postgres.zmwhbssepcywbiahpisi:${{ secrets.DB_PASSWORD }}@aws-1-us-east-1.pooler.supabase.com:5432/postgres" \
    #       -c "
    #       -- Grant database-level permissions
    #       GRANT ALL PRIVILEGES ON DATABASE breadnotes TO breadnotes;
    #       -- Grant schema permissions
    #       GRANT ALL ON SCHEMA public TO breadnotes;
    #       GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO breadnotes;
    #       GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO breadnotes;
    #       ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO breadnotes;
    #       ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON SEQUENCES TO breadnotes;
    #       " 2>/dev/null || echo "Permissions may already be set or database doesn't exist yet"

    - name: Run database migrations
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: breadnotes-api
        IMAGE_TAG: ${{ github.sha }}
      run: |
        echo "Running database migrations..."
        echo "Debug: DB_HOST = ${{ secrets.DB_HOST }}"
        echo "Debug: DB_NAME = ${{ secrets.DB_NAME }}"
        echo "Debug: DB_USER = ${{ secrets.DB_USER }}"
        echo "Debug: DB_PASSWORD = [HIDDEN]"
        echo "Debug: DB_URL = postgresql://${{ secrets.DB_USER }}:PASSWORD@${{ secrets.DB_HOST }}:${{ secrets.DB_PORT }}/${{ secrets.DB_NAME }}"

        docker run --rm -e DB_HOST="${{ secrets.DB_HOST }}" -e DB_NAME="${{ secrets.DB_NAME }}" -e DB_USER="${{ secrets.DB_USER }}" -e DB_PASSWORD="${{ secrets.DB_PASSWORD }}" $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG uv run python -c "from app.core.config import settings; print(f'DB_HOST: {settings.db_host}')"
        
        docker run --rm -e DB_HOST="${{ secrets.DB_HOST }}" -e DB_NAME="${{ secrets.DB_NAME }}" -e DB_USER="${{ secrets.DB_USER }}" -e DB_PASSWORD="${{ secrets.DB_PASSWORD }}" $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG uv run python -c "from app.core.config import settings; print(f'DB_URL: {settings.database_url.replace(settings.db_password, \"***\")}')"

        # Test the connection string construction
        echo "Running database migrations..."
        docker run --rm \
          -e DB_HOST="${{ secrets.DB_HOST }}" \
          -e DB_NAME="${{ secrets.DB_NAME }}" \
          -e DB_USER="${{ secrets.DB_USER }}" \
          -e DB_PASSWORD="${{ secrets.DB_PASSWORD }}" \
          $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
          uv run alembic upgrade head

    - name: Deploy to App Runner
      run: |
        echo "Getting App Runner service ARN..."
        SERVICE_ARN=$(aws apprunner list-services \
          --query "ServiceSummaryList[?ServiceName=='breadnotes-api'].ServiceArn | [0]" \
          --output text)
        
        if [ "$SERVICE_ARN" = "None" ] || [ -z "$SERVICE_ARN" ]; then
          echo "Error: App Runner service 'breadnotes-api' not found"
          exit 1
        fi
        
        echo "Found App Runner service: $SERVICE_ARN"
        
        # Check if service is in RUNNING state before deployment
        STATUS=$(aws apprunner describe-service --service-arn "$SERVICE_ARN" --query "Service.Status" --output text)
        echo "Current service status: $STATUS"
        
        if [ "$STATUS" != "RUNNING" ]; then
          echo "Service is not in RUNNING state. Current state: $STATUS"
          echo "Waiting for service to be ready..."
          exit 1
        fi
        
        echo "Triggering App Runner deployment..."
        aws apprunner start-deployment --service-arn "$SERVICE_ARN"

    - name: Build and Deploy Frontend
      run: |
        echo "Building frontend..."
        cd web
        npm ci
        # Set the API URL to the CloudFront distribution
        export VITE_API_URL="${{ secrets.VITE_API_URL }}"
        npm run build
        
        echo "Deploying frontend to S3..."
        # Configure AWS CLI with the same credentials
        aws configure set aws_access_key_id ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws configure set aws_secret_access_key ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws configure set default.region ${{ secrets.AWS_REGION }}
        
        # Sync build files to S3 frontend bucket (force overwrite)
        aws s3 sync dist/ s3://breadnotes-prod-frontend --delete --exact-timestamps --size-only
        
        # Invalidate CloudFront cache - find frontend distribution by S3 origin
        DISTRIBUTION_ID=$(aws cloudfront list-distributions --query "DistributionList.Items[?Origins.Items[?contains(DomainName, 'breadnotes-prod-frontend')]].Id | [0]" --output text)
        if [ ! -z "$DISTRIBUTION_ID" ] && [ "$DISTRIBUTION_ID" != "None" ]; then
          echo "Invalidating CloudFront distribution: $DISTRIBUTION_ID"
          aws cloudfront create-invalidation --distribution-id $DISTRIBUTION_ID --paths "/*"
        else
          echo "No CloudFront distribution found for frontend"
        fi
